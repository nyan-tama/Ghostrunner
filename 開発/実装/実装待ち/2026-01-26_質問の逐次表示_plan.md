# 質問の逐次表示機能 実装計画

## 概要

現在、フロントエンドのUIで複数の質問がある場合、すべての質問が一度に表示されている。
ユーザーの要望として、質問を一つずつ順番に表示してほしいという要求がある。

## 現状分析

### 問題点

1. `QuestionSection.tsx`で`questions.map()`を使用して全質問を一度に表示
2. ユーザーが複数の質問を同時に見ることになり、混乱する可能性
3. 現在の実装では、質問ごとに状態管理（`customAnswers`, `selectedOptions`）を行っているが、全質問が同時表示されているため複雑

### 影響範囲

**フロントエンドのみの変更**
- `frontend/src/components/QuestionSection.tsx`: 質問表示ロジックの変更
- `frontend/src/types/index.ts`: 型定義の確認（変更不要の可能性）

**バックエンドは変更不要**
- バックエンドは既に複数の質問を配列で送信している
- フロントエンドで表示制御を行う

## 懸念点

### 1. `currentQuestionIndex` の管理場所

**重要な前提**: `page.tsx`の`handleAnswer`内で`setShowQuestions(false)`が実行され、質問UIが一旦非表示になる。バックエンドからの応答で再表示される。つまり、`QuestionSection`コンポーネントはアンマウント→再マウントされる。

**懸念**:
- `currentQuestionIndex`を`QuestionSection`内部で管理すると、コンポーネントが再マウントされるたびにリセットされてしまう

**選択肢**:
1. **親コンポーネントで管理（推奨）**: `page.tsx`で`currentQuestionIndex`を状態管理
   - メリット: コンポーネントの再マウントに影響されない
   - デメリット: 親コンポーネントの変更が必要

2. **親の挙動変更**: `handleAnswer`内の`setShowQuestions(false)`を削除
   - メリット: `QuestionSection`内で完結できる
   - デメリット: 既存のUX（ローディング中に質問UIを非表示）を変更することになる

**決定**: **選択肢1（親コンポーネントで管理）** を採用
- 既存のUXを維持しつつ、質問の逐次表示を実現できる
- `page.tsx`に`currentQuestionIndex`状態を追加し、propsで渡す

### 2. 質問の回答方法

**懸念**:
- バックエンドに質問を一つずつ送るべきか、全て集めてから送るべきか？

**選択肢**:
1. **表示のみ逐次化（推奨）**: UIでは一問ずつ表示するが、回答はバックエンドに即座に送信
   - メリット: シンプル、既存の実装を大きく変更しない
   - デメリット: バックエンドとの通信が複数回発生（ただし現在も同じ）

2. **全回答収集方式**: 全ての質問に回答してから一度に送信
   - メリット: バックエンドへの通信が1回で済む
   - デメリット: バックエンドAPIの変更が必要、実装が複雑

**決定**: **選択肢1（表示のみ逐次化）** を採用
- バックエンドAPIの変更不要
- ユーザーは一問ずつ集中して回答できる

### 3. 進捗表示

**懸念**:
- 「現在 3 問中 1 問目」のような進捗を表示すべきか？

**選択肢**:
1. **進捗表示なし**: 現在の質問のみ表示
   - メリット: シンプル
   - デメリット: あと何問あるか分からない

2. **進捗表示あり（推奨）**: 「質問 1/3」のような表示を追加
   - メリット: ユーザーが全体像を把握できる
   - デメリット: UI の追加実装が必要（ただし軽微）

**決定**: **選択肢2（進捗表示あり）** を採用
- 実装コストが低い
- ユーザー体験の向上

## 推奨アプローチ

**親コンポーネントで状態管理 + 表示のみ逐次化 + 進捗表示あり**

理由:
- 既存の`onAnswer`の挙動を変更しない
- 既存のUX（ローディング表示）を維持
- ユーザーが一つずつ質問に集中でき、全体の進捗も把握できる

## 実装計画

### フロントエンド変更

#### 1. page.tsx の変更

**追加する状態**:
- `currentQuestionIndex: number` - 現在表示中の質問のインデックス
- 初期値: `0`
- `questions`が変更されたら`0`にリセット

**追加する関数**:
- `handleAnswerWithNext: (answer: string) => void`
  - 現在の`handleAnswer`を呼び出す
  - `currentQuestionIndex`をインクリメント
  - ただし、最後の質問の場合は既存の挙動（バックエンドに送信）

**変更する props**:
- `QuestionSection`に`currentQuestionIndex`を渡す
- `onAnswer`の代わりに`handleAnswerWithNext`を渡す

#### 2. QuestionSection.tsx の変更

**追加する props**:
- `currentQuestionIndex: number` - 現在表示すべき質問のインデックス

**変更する処理**:
- 質問表示: `questions[currentQuestionIndex]`のみを表示（`map`を削除）
- 進捗表示: `currentQuestionIndex + 1` / `questions.length`を表示
- 回答送信時: `onAnswer`を呼ぶだけ（インクリメントは親が行う）

**簡略化する状態**:
- `customAnswers: Record<number, string>` → `customAnswer: string`
- `selectedOptions: Record<number, string[]>` → `selectedOptions: string[]`
- インデックスが不要になるため

**削除する処理**:
- `questions.map()`によるループ
- `idx`パラメータの使用

#### 3. 型定義の確認

`frontend/src/types/index.ts`の`Question`型は変更不要。

### 実装ステップ

1. `page.tsx`に`currentQuestionIndex`状態を追加
2. `page.tsx`に`useEffect`を追加し、`questions`変更時に`currentQuestionIndex`を0にリセット
3. `page.tsx`に`handleAnswerWithNext`関数を追加
4. `page.tsx`から`ProgressContainer`へのpropsに`currentQuestionIndex`を追加
5. `ProgressContainer.tsx`のprops定義に`currentQuestionIndex`を追加し、`QuestionSection`に渡す
6. `QuestionSection.tsx`のprops定義に`currentQuestionIndex`を追加
7. `QuestionSection.tsx`で状態を簡略化（`Record<number, T>`から`T`へ）
8. `QuestionSection.tsx`で`questions.map()`を削除し、`questions[currentQuestionIndex]`のみをレンダリング
9. `QuestionSection.tsx`に進捗表示を追加（例: `質問 1/3`）
10. 境界チェック: `currentQuestionIndex >= questions.length`の場合は何も表示しない

### テスト観点

- 単一質問の場合、正常に表示・回答できること
- 複数質問の場合、一つずつ順番に表示されること
- 最後の質問に回答したら、質問セクションが非表示になること
- マルチセレクトの質問が正常に動作すること
- カスタム回答が正常に動作すること

## 変更ファイル一覧

- `frontend/src/app/page.tsx`:
  - `currentQuestionIndex`状態の追加
  - `handleAnswerWithNext`関数の追加
  - `useEffect`で`questions`変更監視
  - `ProgressContainer`へのprops追加（`currentQuestionIndex`を渡す）
- `frontend/src/components/ProgressContainer.tsx`:
  - props定義の変更（`currentQuestionIndex`追加）
  - `QuestionSection`へのprops追加
- `frontend/src/components/QuestionSection.tsx`:
  - props定義の変更（`currentQuestionIndex`追加）
  - 質問表示ロジックの変更（`map`削除、単一質問表示）
  - 状態の簡略化（`Record<number, T>`から`T`へ）
  - 進捗表示の追加

## 実装後の動作

1. バックエンドから複数の質問が送られてくる
2. `page.tsx`で`questions`が設定され、`currentQuestionIndex`が0にリセットされる
3. `showQuestions`が`true`になり、`QuestionSection`が表示される
4. フロントエンドは`questions[0]`（最初の質問）のみを表示、進捗表示「質問 1/3」を表示
5. ユーザーが回答すると:
   - 最後の質問でない場合: `currentQuestionIndex`をインクリメントし、次の質問を表示（バックエンド通信なし）
   - 最後の質問の場合: `handleAnswer`を呼び、バックエンドに送信→ローディング表示
6. 最後の質問でない場合は、すぐに次の質問（`questions[1]`など）が表示される
7. 最後の質問に回答すると、既存の挙動（ローディング→結果表示）に従う

## エッジケースの扱い

### 1. `questions` が変更された場合

- `useEffect`で`questions`を監視し、変更があれば`currentQuestionIndex`を0にリセット
- これにより、バックエンドから新しい質問セットが来た場合に最初から表示される

### 2. `currentQuestionIndex >= questions.length`の場合

- `QuestionSection`コンポーネントの先頭で境界チェックを行う
- 条件: `!visible || questions.length === 0 || currentQuestionIndex >= questions.length`
- この場合は`null`を返して何も表示しない

### 3. ローディング状態の扱い

- 最後の質問でない場合: `handleAnswerWithNext`は`handleAnswer`を呼ばないため、ローディング表示にならない
- 最後の質問の場合: `handleAnswer`を呼び、既存のローディング表示動作を実行
- これにより、中間の質問では即座に次の質問が表示され、最後の質問でのみバックエンド通信が発生

### 4. 最後の質問の判定

- `currentQuestionIndex === questions.length - 1`で判定
- この場合のみ`handleAnswer`を呼んでバックエンドに送信
- それ以外は`currentQuestionIndex`をインクリメントするだけ

## 備考

- バックエンドの変更は不要
- 最後の質問以外では`handleAnswer`を呼ばないため、バックエンド通信が発生しない
- 最後の質問に回答した時のみ既存の`handleAnswer`の動作（ローディング→バックエンド送信→結果表示）が実行される
